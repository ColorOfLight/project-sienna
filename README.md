# Project Sienna

A 3D airbrush painting simulator that runs in your browser, enabling real-time painting and color blending on 3D objects.

[Live Webpage](https://project-sienna.coloroflight.dev/)

## Core Features

- **Paint directly onto 3D objects** based on user pointer input, using **OpenGL shaders and perspective projection** for writing directly to textures, simulating brush strokes. üé®
- **Realistic color blending** with smooth transitions using **ping pong textures**. üåà
- **Browser-based user interactions** managed with [Emscripten](https://emscripten.org/), enabling responsive **WebAssembly** logic. üåê

## System Architecture

The project follows a traditional **[ECS (Entity-Component-System)](https://en.wikipedia.org/wiki/Entity_component_system)** architecture with an added **View** layer for convenience. Entities are managed through a **RootManager**, which is responsible for creating, updating, and removing entities, as well as initializing their associated components as needed.

| **Component**   | **Description**                                                                          |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Entity**      | Represents a game object by grouping related Components.                                 |
| **Component**   | Holds data and includes simple functions that do not take other Components as arguments. |
| **View**        | Created from Entities and Components, and is used as an argument for Systems.            |
| **System**      | Contains the logic that takes Components and Views as arguments for execution.           |
| **RootManager** | Manages Entities and can initialize Entities or their Components as needed.              |

## Project Structure

The project is divided into two main parts: the **C++ backend** and the **web frontend**, ensuring a clear separation between the core simulation logic and the user interface.

### C++ Backend (/cpps)

The backend is responsible for core logic, painting algorithms, and rendering setup. It is compiled into **WASM** using **Emscripten** (via a CMake toolchain). The build system is managed using **[CMake](https://cmake.org/)**, and **[Ninja](https://ninja-build.org/)** is used for efficient builds.

| **Directory**      | **Description**                                                                                        |
| ------------------ | ------------------------------------------------------------------------------------------------------ |
| **`include/`**     | Contains header files.                                                                                 |
| **`src/`**         | Includes all the C++ source files implementing the core logic, including shaders and texture handling. |
| **`third-party/`** | Holds external dependencies like **[glm](https://github.com/g-truc/glm)**.                             |

### Web Frontend (/web)

The frontend is built with **[Vite](https://vitejs.dev/)** and provides an interface to interact with the simulation in the browser.

- **User Interface**: A simple UI built with [tweakpane](https://tweakpane.github.io/docs/).
- **WebAssembly Integration**: Uses JavaScript and WASM files from the C++ backend, which are generated by Emscripten.

## How to Run the Project

### Compile from C++

You need **CMake** and **Ninja** for the process.

```zsh
# Load Emscripten SDK
# - If you already have the emsdk, skip this step;
# - you can verify by running `emcc -v` to check if it's installed

git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
source ./emsdk_env.sh
cd ..

# Generate build system with CMake
# - You can choose preset in cpps/CMakePresets.json
cd cpps
cmake . --preset=debug
# cmake . --preset=release

# Build js and WASM file
cd build-debug
# cd build-release
ninja

# After the build, you can test the result with running a web project
```

### Run Web Project

You need **Node.js v20+** for the process.

```zsh
# Move to /web directory
cd web

# Install dependencies
npm i

# Start dev server
npm run dev
```

## Versioning

### How to Upgrade Version

1. Change version in `cpps/CMakeLists.txt` and `web/package.json`
2. Add a new version log file to `version-logs`
3. Build new JS and WASM file with preset `release`
4. Commit the changes to git
5. Merge the changes from `main` branch into `release` branch
6. Add a new git tag with version name (e.g., `v0.1.0`)
